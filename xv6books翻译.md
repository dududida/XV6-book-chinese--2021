


# 目录

[2.5 Process overview](#25-process-overview)

[2.6 Code: starting xv6, the first process and system call](#26-code-starting-xv6-the-first-process-and-system-call)

[2.7 Security Model](#27-security-model)

[3.1 Paging hardware](#31-paging-hardware)

[3.2 Kernel address space](#32-kernel-address-space)

[3.3 Code: creating an address spaces](#33-code-creating-an-address-space)

[3.4 Physical memory allocation](#34-physical-memory-allocation)

[3.5 Code: Physical memory allocator](#35-code-physical-memory-allocator)

[3.6 Process address space](#36-process-address-space)

# Chapter 2

##  2.5 Process overview

xv6为每一个进程单独维护一个页表，这个页表就定义了进程的地址空间。如图2.3所示，是一个包含了进程的用户空间的地址空间，它从虚拟地址0开始。首先是指令，随后是全局变量，栈，最后是堆（根据需要，用户可以通过malloc动态的扩展堆）。有多个因素限制了进程地址空间的最大值：Risc-V架构下的指针是64位；硬件只使用低39位来在页表中寻找虚拟地址；xv6只使用了39位中的38位。因此，最大虚拟地址为$2^{38}-1=$ 0x3fffffffff,在kernel/riscv.h:363中被定义为MAXVA。在地址空间的最高地址处，xv6为*trampoline*保留了一页，也保留了一页来映射进程的*trapframe*。xv6通过这两页来进入内核以及退出内核；*trampoline*这一页包含了进入和退出内核的代码；对*trapframe*的映射是必要的，它可以保存/恢复用户进程的状态，正如我们将在第 4 章中解释的那样。

Xv6内核为每个进程维护许多状态片段，它将这些状态收集到一个结构体proc(kernel/proc.h:86)中。一个进程最重要的内核状态片段是它的页表、内核栈和运行状态。我们将使用符号p->xxx来引用proc结构体中的元素；例如，p->pagetable是指向进程的页表的指针。

每个进程都有一个执行线程(简称线程)来执行进程的指令。一个线程可以被挂起，然后被恢复。为了在进程之间透明地切换，内核挂起当前正在运行的线程并恢复另一个进程的线程。线程的大部分状态(本地变量，函数调用返回地址)都存储在线程的栈中。每个进程都有两个栈: 一个用户栈和一个内核栈(p->kstack)。当进程执行用户指令时，只有它的用户栈在使用，而它的内核栈是空的。当进程进入内核(系统调用或中断)时，内核代码在进程的内核堆栈上执行; 当进程在内核中时，其用户栈仍然包含已保存的数据，但不会被主动使用。进程的线程在主动使用用户栈和内核栈之间交替。内核栈是独立的(被保护起来，远离用户代码) ，因此即使进程破坏了它的用户栈，内核也可以执行。

进程可以通过执行RISC-V的ecall指令进行系统调用。这条指令提升了硬件特权级别，并将程序计数器改为内核定义的入口点。入口点的代码切换到内核栈并执行内核指令来实现系统调用。当系统调用完成时，内核切换回用户栈，并通过调用sret指令返回用户空间，这降低了硬件特权级别，继续执行系统调用指令之后的那条用户指令。进程的线程可以在内核中“阻塞”以等待I/O，并在I/O完成后继续刚才暂停的工作。

p->state指示了进程是否已被分配、准备运行、运行、等待I/O或退出。

P->pagetable保存进程的页表，其格式符合RISC-V的硬件要求。Xv6让分页硬件在用户空间执行进程时使用进程的p->pagetable。一个进程的页表也可以作为分配给进程的物理页面地址的记录。

总之，进程捆绑了两个设计思想: 通过地址空间来给进程一种独自占有内存的错觉；通过一个线程来给进程一种独占CPU的错觉。在xv6中，一个进程由一个地址空间和一个线程组成。在真实的操作
系统中，一个进程可能有多个线程来利用多个CPU。

##  2.6 Code: starting xv6, the first process and system call

为了使xv6更具体，我们将概述内核如何启动和运行第一个进程。接下来的章节将更详细地描述在这个概述中出现的机制。

当RISC-V计算机启动时，它初始化自己并运行一个引导加载程序，该引导加载程序存储在只读内存中。引导加载程序将xv6内核加载到内存中。然后，在机器模式下，CPU 从_entry(kernel/entry.s:7)开始执行xv6。此时RISC-V分页硬件并没有工作:虚拟地址直接映射到物理地址。

加载器将xv6内核加载到物理地址0x80000000的内存中。它把内核放在0x8000000而不是0x0的原因是因为地址范围 0x0:0x8000000包含I/O设备。

_entry中的指令设置了一个栈，以便xv6可以运行c代码。xv6 在start.c(kernel/start.c:11)文件中声明了初始栈stack0的空间。_entry处的代码用堆栈顶部的地址stack0+4096 初始化栈指针寄存器sp，因为RISC-V架构下的栈向低地址增长。现在内核有了堆栈，_entry调用c代码(kernel/start.c:21)。

函数start执行一些只允许在机器模式下进行的配置，然后切换到管理模式。为了进入管理模式，RISC-V提供了指令mret。这个指令最常用于从上一个调用从管理模式返回到机器模式。虽然start不是从这样的调用中返回，但它仍当作是从这样的调用中返回的，并设置一些东西: 它将mstatus寄存器中保存的模式标志设置为管理模式；它将main的地址写入寄存器mepc来作为返回地址；将0 写入页表寄存器satp，在管理模式中禁用虚拟地址转换；并将所有中断和异常委托给管理模式。

在进入管理模式之前，start还要执行一项任务：它对时钟芯片进行编程以生成计时器中断。这些都处理完毕，start通过调用 mret“返回”到管理模式。这会将程序计数器置为为main的地址(kernel/main.c: 11)

在main(kernel/main.c:11)初始化几个设备和子系统之后，它通过调用userinit(kernel/proc.c:226)创建第一个进程。第一个进程执行一个用RISC-V汇编写的小程序，使用xv6进行第一次系统调用。initcode.S(user/initcode.S:3)将exec的系统调用号SYS_EXEC(kernel/syscall.h:8)加载到寄存器a7中，然后调用ecall重新进入内核。

内核使用寄存器a7中的数字来调用syscall(kernel/syscall.c: 133)中的系统调用。系统调用表(kernel/syscall.c: 108)将SYS_EXEC映射到内核调用的sys_exec。正如我们在第1章中看到的，exec用一个新程序(在本例中是/init)替换了当前进程的内存和寄存器。

一旦内核完成了exec，它将返回到/init进程中的用户空间。Init(user/Init.c:15)在需要的时候创建一个新的控制台设备文件，然后打开它的文件描述符0、1、2。然后在控制台上启动一个shell。系统启动了。

##  2.7 Security Model

你可能想知道操作系统是如何处理错误或恶意代码的。因为处理恶意软件比处理意外的错误更加困难，所以将这个话题视为与安全有关是合理的。下面是一个关于操作系统设计中典型的安全假设和目标的宏观观点。

操作系统必须假设一个进程的用户级代码会破坏内核或其他进程。用户代码可能会尝试在其允许的地址空间之外引用指针；它可能尝试执行任何RISC-V指令，甚至那些不是用户代码的指令；它可能尝试读写任何RISC-V控制寄存器；它可能尝试直接访问设备硬件；它可能向系统调用传递“巧妙”的值，来使内核崩溃。内核的目标是限制每个用户进程，使它们所能做的就是读/写/执行它自己的用户内存，使用32个通用RISC-V寄存器，并以系统调用允许的方式影响内核和其他进程。内核必须阻止任何其他操作。这是内核设计中的一个必然要求。

对内核自身的代码我们的期望完全不同。内核代码被认为是由无恶意和谨慎的程序员编写的。内核代码应该是没有bug的，当然也不能包含任何恶意的东西。这个假设影响了我们分析内核代码
的方式。例如，有许多内核函数(例如自旋锁) ，如果内核代码不正确地使用它们，就会导致严重的问题。当检查任何一段特定的内核代码时，我们都试图相信它的行为是正确的。我们假设内核代码通常是编写正确的，并遵循相关规则。在硬件层面，RISC-V CPU、RAM、磁盘等被假定为按照文档中描述的那样运行，没有硬件错误。

当然，在现实生活中，事情并不是那么简单。我们很难去防止一些代码通过消耗受内核保护的资源(磁盘空间、CPU时间、进程表槽等)而使系统无法使用(或导致系统恐慌)。编写无缺陷代码或设计无缺陷硬件通常是不可能的；如果恶意用户代码的编写者知道内核或硬件缺陷，他们就会利用这些缺陷。我们可以在内核中进行如下设计来防止bug：诊断、类型检查、栈保护页面等等。最后，用户代码和内核代码之间的区别有时是模糊的: 一些特权用户级进程可以提供必要的服务，有效地成为操作系统的一部分，在一些操作系统中，特权用户代码可以在内核中插入新的代码(与Linux的可加载内核模块一样)。


# Chapter 3 Page table

页表是最常用的机制，通过它，操作系统为每个进程提供自己的私有地址空间和内存。页表决定了内存地址的含义，以及物理内存的哪些部分可以被访问。它允许xv6隔离不同进程的地址空间，并将它们映射在同一个物理内存上。页表是一种流行的设计，因为它允许操作系统在一定程度上间接性地施展一些策略。例如：在几个地址空间中映射相同的内存(trampoline page) ，并使用一个未映射的页面保护内核和用户栈。本章的其余部分解释了RISC-V硬件提供的页表以及xv6如何使用它们。

## 3.1 Paging hardware

提醒，RISC-V指令(用户和内核)都操作虚拟地址。机器的RAM，或者说物理内存，是用物理地址索引的。RISC-V页表硬件通过将每个虚拟地址映射到一个物理地址来连接这两种地址。

Xv6在RISC-V的Sv39格式上运行，这意味着只使用64位虚拟地址的低39位，而不使用高25位。在这个sv39格式中，RISC-V页表在逻辑上是由$2^{27}$个页表条目(PTEs，page table entrys)组成的数组。每个PTE包含一个44位的物理页号(PPN，physical page number)和一些标志位。分页硬件通过使用39位中的高27位对页表进行索引来转换虚拟地址，从而找到一个 PTE，并生成一个56位物理地址，其高44位来自PTE中的PPN，其低12位来自原始虚拟地址。图3.1显示了这个过程，页表的逻辑视图是一个简单的PTEs数组（图3.2提供了更完整的描绘）。一个页表为操作系统提供了对4096($2^{12}$)个字节大小对齐的块进行虚拟到物理地址转换的控制。这样的块被称为页面。

在Sv39 RISC-V中，虚拟地址的前25位不用于转换。物理地址也有增长的空间: PTE格式的物理页号还有增长10位的空间。RISC-V的设计者根据技术预测选择了这些数字。$2^{39}$字节是512GB，这样大的地址空间对于在Risc-V机器上运行的应用来说应该是足够的。$2^{56}$大小的物理地址上限对于适应近期的I/O设备和DRAM芯片也是足够的。如果需要更大的地址，Risc-V的设计者们已经定义了48位的虚拟地址。

如图3.2所示，RISC-V CPU通过三个步骤将虚拟地址转换为物理地址。一个页表以三级树的形式存储在物理内存中。树的根是一个4096字节的页表页面，其中包含512个PTE，这些PTE包含了树的下一级别页表的物理地址。每个页面都包含512个PTE，用于树的最后一级。分页硬件使用27位中的高9位在根页表页面中选择 PTE，中间的9位在树的下一级别的页表中选择PTE，低的9位选择最终的PTE。(在Sv48 RISC-V中，页表有四个级别，虚拟地址索
引的39位到47位进入顶级。)

如果转换地址所需的三个PTE中的任何一个不存在，则分页硬件将引发页面错误异常，将其留给内核处理异常(参见第 4 章)。

与图3.1的单级设计相比，图3.2的三级结构记录PTEs会更加节省内存。在大范围的虚拟地址没有映射的情况下，三级结构可以省略整个页面目录。例如，如果一个应用程序只使用从地址零开始的几个页面，那么顶级页面目录的条目1到511是无效的，内核不必为 511个中间页面目录分配这些页面。此外，内核也不需要为底层的511个中间页目录分配页面。因此，在这个例子中，三级设计为中间页目录节省了511页，为底层页目录节省了$511\times 512$页。

虽然CPU在执行加载或存储指令时使用硬件中的三级结构，但是三级结构的潜在缺点是CPU必须从内存中加载三个PTE，才能将加载/存储指令中的虚拟地址转换为物理地址。为了避免吗从物理内存加载PTEs的成本，RISC-V CPU 在Translation Look-aside Buffer(TLB)中缓存页表条目。

每个PTE包含标志位，它告诉分页硬件如何使用相关的虚拟地址。PTE_V指示PTE是否存在: 如果没有设置，对页面的引用将导致异常(即不允许)。PTE_R控制指令是否被允许读取到页面。PTE_W控制是否允许指令写入页面。PTE_X控制CPU是否可以将页面内容解释为指令并执行它们。PTE_U控制是否允许用户模式下的指令访问页面；如果未设置PTE_U，则PTE只能在管理模式下使用。图3.2 展示了它是如何工作的。标志和所有其他与页面硬件相关的结构在(kernel/riscv.h)中定义。

要告诉硬件使用页表，内核必须将根页表页的物理地址写入satp寄存器。每个CPU都有自己的satp。一个 CPU 将使用它自己的 satp指向的页表来转换后续指令生成的所有地址。每个 CPU 都有自己的satp，这样不同的 CPU 可以运行不同的进程，每个进程
都有自己的页表所描述的私有地址空间。

通常一个内核会将所有的物理内存映射到它的页表中，这样它就可以使用加载/存储指令读写物理内存中的任何位置。由于页面目录位于物理内存中，内核可以使用标准存储指令写入 PTE 的虚拟地址，从而对页面目录中的 PTE 内容进行编程。

关于术语的几点注意事项。物理内存是指 DRAM 中的存储单元。一个字节的物理内存有一个地址，叫做物理地址。指令只使用虚拟地址，分页硬件将其转换为物理地址，然后发送到 DRAM 硬件进行读取/写入。与物理内存和虚拟地址不同，虚拟内存不是一个物理对象，而是指内核提供的用于管理物理内存和虚拟地址的抽象和机制的集合。

##  3.2 Kernel address space

Xv6 每个进程维护一个页表，描述每个进程的用户地址空间，外加一个描述内核地址空间的单页表。内核配置其地址空间的布局，以便在可预测的虚拟地址上访问物理内存和各种硬件资源。图 3.3 显示了这种布局如何将内核虚拟地址映射到物理地址。文件(kernel/memlayout.h)声明了 xv6 内核内存布局的常量。

QEMU 模拟了一台包含 RAM (物理内存)的计算机，从物理地址 0x8000000开始，至少持续到0x86400000，xv6 称之为PHYSTOP。QEMU 模拟还包括 I/O 设备，如磁盘接口。QEMU将设备接口公开给软件作为内存映射控制寄存器，这些寄存器位于物理地址空间的 0x8000000 以下。内核可以通过读写这些特殊的物理地址与设备交互；这些读写通信是与设备硬件而不是RAM。第四章解释了xv6如何与设备交互。

内核使用“直接映射”获得 RAM 和内存映射设备寄存器，即在与物理地址相等的虚拟地址上映射资源。例如，内核本身在虚拟地址空间和物理内存中都位于KERNBASE = 0x80000000。直接映射简化了读写物理内存的内核代码。例如，当 fork 为子进程分配用户
内存时，分配器返回该内存的物理地址； fork 在将父进程的用户内存复制到子进程时，直接将该地址用作虚拟地址。

有一些内核虚拟地址不是直接映射的：

- Trampoline page。它被映射到虚拟地址空间的顶部；用户页表也有相同的映射。第4章讨论了Trampoline page的作用，我们在这里看到了一个有趣的页表用例；一个物理页面(包含着Trampoline code)在内核的虚拟地址空间中被映射了两次: 一次在虚拟地址空间的顶部，一次通过直接映射。

- Kernel stack pages。每个进程都有自己的内核栈，这个栈被映射到地址比较高的地方，因此 xv6 可以在它下面保留一个未映射的保护页面。保护页面的 PTE 无效(即未设置 PTE_V) ，因此如果内核栈溢出，它可能会导致异常，内核将会panic。但如果没有保护页面，溢出的栈会覆盖其他内核内存，导致不正确的操作。显然panic crash是更好的选择。

内核既可以通过向高地址映射使用其栈，也可以通过直接映射的地址访问内核。另一种设计是只有直接映射，并在直接映射的地址使用栈。然而，在这种设计下，提供保护页面就需要取消虚拟地址映射，否则这些虚拟地址会引用物理内存，这样就很难用了。

内核用权限PTE_R和PTE_X映射Trampoline页面和内核文本页面。内核从这些页面读取和执行指令。内核用权限PTE_R和PTE_W映射其他页面，这样它就可以读写这些页面中的内存。注意，保护页面的映射是无效的。

##  3.3 Code: creating an address space

大部分用于操作地址空间和页表的xv6代码都在vm.c中(kernel/vm.c:1)。中心数据结构是pagetable_t，它实际上是一个指向 RISC-V 根页表页面的指针；一个pagetable_t可以是内核页表，也可以是每个进程的页表之一。中心函数是walk，它为一
个虚拟地址找到PTE，以及mappages，即为新的映射分配PTE。以kvm开头的函数操作内核页表；以uvm开头的函数操作用户页表； 其他函数服务于两者。copyout和copyin复制数据到用户虚拟地址或从用户虚拟地址复制数据，这些数据作为系统调用参数提供；copyin/out在 vm.c中，是因为它们需要显式地翻译这些地址，以便找到相应的物理内存。

在机器启动的最初阶段，main调用kvminit(kernel/vm.c: 54)来使用kvmmake (kernel/vm.c: 20)创建内核的页表。这个调用发生在xv6启用RISC-V 上的分页之前，因此地址直接指向物理内存。Kvmmake首先分配一个物理内存页面来保存根页表页面。然后它调用kvmmap来完成内核需要的映射。映射包括内核的指令和数据，直到PHYSTOP区域的物理内存，以及实际上是描述设备的内存范围。Proc_mapstacks(kernel/proc.c:33)为每个进程分配一个内核栈。它调用kvmmap将每个堆栈映射到KSTACK生成的虚拟地址，这样就为栈保护页面留下了空间。

kvmmap(kernel/vm.c:127)调用mappages(kernel/vm.c:138) ，它将一个虚拟地址范围的映射安装到一个页表中，并将其映射到相应的物理地址范围。它对范围内的每个虚拟地址按页面间隔分别执行此操作。对于每个要映射的虚拟地址，映射调用遍历以找到该地址的PTE地址。然后，它初始化PTE以保存相关的物理页好、所需的权限(PTE_W、PTE_X、PTE_R) ，以及PTE_V以标记PTE为有效(kernel/vm.c:153)。

walk(kernel/vm.c:81)在查找PTE虚拟地址时模拟 RISC-V 分页硬件(参见图 3.2)。walk同时使用3级页表的索引。它使用每个级别的9位虚拟地址来查找下一级别页表或最终页(kernel/vm.c: 87)的PTE。如果 PTE 无效，则所需的页面尚未分配；如果设置了alloc参数，则 walk 将分配一个新的页面，并将其物理地址放在PTE中。它返回树中最底层的PTE地址(kernel/vm.c: 97)。

上面的代码依赖于直接映射到内核虚拟地址空间的物理内存。例如，当walk进入下一级页表时，它从 PTE (kernel/vm.c: 89)中提取下一级别页表的(物理)地址，然后使用该地址作为虚拟地址来提取下一级别下的PTE(kernel/vm.c: 87)。

main调用kvminithart(kernel/vm.c: 62)来安装内核页表。它将根页表页面的物理地址写入寄存器satp。在这之后，CPU 将使用内核页表转换地址。由于内核使用identity mapping，下一条指令的现在虚拟地址将映射到正确的物理内存地址。

每个RISC-V CPU都在快表(TLB)中缓存页表条目，当xv6更改页表
时，它必须告诉CPU使相应缓存的TLB条目无效。如果没有，那么在以后的某个时候，TLB可能会使用一个旧的缓存映射，指向一个物理页面，这个页面在此期间已经被分配给另一个进程，因此，一个进程可能会在另一个进程的内存上读写。RISC-V 有一个指令 sfence.vma 可以刷新当前 CPU 的 TLB。Xv6 在重新加载 satp寄存器之后用 kvminithart 执行 sfence.vma，并在trampoli code中切换到用户页表，这个切换是在返回到用户空间之前完成的(kernel/trampoline.S:79)。

为了避免刷新全部的TLB条目，RISC-V CPU支持地址空间标识符(ASIDs)。内核可以只刷新特定地址空间的 TLB 条目。

##  3.4 Physical memory allocation

内核必须在运行时为页表、用户内存、内核栈和管道缓冲区分配和释放物理内存。Xv6 使用内核空间和PHYSTOP之间的物理内存进行运行时分配(参考图 3.3)。它一次分配和释放整个4096字节的页面。它通过链表来跟踪哪些页面是空闲的。分配是从链表中删除一个页面；释放是将释放的页面添加到链表中。

##  3.5 Code: Physical memory allocator

分配器位于kalloc.c(kernel/kalloc.c: 1)。分配器的数据结构是一个可用于分配的物理内存页面的空闲链表。每个空闲页面对应的的链表元素是一个struct run(kernel/kalloc.c: 17)。分配器从哪里获得内存来保存这个数据结构呢？它将每个空闲页面的run struct就存储在对应的空闲页面中，因为空闲页面中也不存放其他东西。空闲链表由自旋锁保护(kernel/kalloc.c: 21-24)。链表和锁被包装在一个结构体中，以表明这个锁保护该结构中的字段。现在，我们暂时先忽略锁的获取和释放；第6章再来详细研究锁。

函数main调用kinit来初始化分配器(kernel/kalloc.c:27)。kinit初始化空闲链表来保存介于内核空间和PHYSTOP之间的每个页面。xv6通过解析硬件提供的配置信息来确定有多少物理内存可用。xv6假设机器有128MB内存。kinit调用freerange，通过对每页调用kfree来为空闲链表添加内存。PTE只能引用在4096字节边界上对齐的物理地址(是4096的倍数)，因此freerange使用 PGROUNDUP来确保它只释放对齐的物理地址。分配器开始时
并没有内存可分配；是这些对kfree的调用给了它一些内存空间。

分配器有时将地址视为整数，以便对它们执行算术操作(例如，在 freerange中遍历所有页面)，有时将地址用作读写内存的指针(例如，操作存储在每个页面中的run struct)；这种对地址的双重使用是分配器代码充满C类型转换的主要原因。另一个原因是释放和分配从本质上改变了内存的类型。

函数kfree(kernel/kalloc.c: 47)首先将释放的内存中的每个字节设置为值1。这将导致在释放内存后使用内存的代码(使用“悬空引用”)只能读取到无用信息，而不是旧的有效内容；目的是希望这种错误代码更快地停下。然后kfree将页面从头部插入到空闲链表中：它将pa转换为struct run的指针，在r->next中记录空闲链表之前的起始地址，并将空闲链表设置为等于r(译者注：就是链表的头插法嘛，kalloc就是从头部取)。kalloc删除并返回空闲链表中的第一个元素。

##  3.6 Process address space

每个进程都有一个单独的页表，当 xv6 在进程之间切换时，它也会改变页表。如图 2.3 所示，一个进程的用户内存从虚拟地址零开始，可以增长到MAXVA(kernel/riscv.h:360)，允许一个进程在原则上寻址256GB的内存。

当进程向xv6请求更多的用户内存时，xv6 首先使用kalloc来分配物理页面。然后，它将PTEs添加到进程的页表中，指向新的物理页面。xv6在这些PTEs中设置PTE_W、PTE_X、PTE_R、PTE_U 和PTE_V标志。大多数进程不使用整个用户地址空间；xv6在未使用的PTE中保留PTE_V。

我们在这里列举一些使用页表的好处。第一，不同进程的页表将用户地址转换为不同的物理内存页面，这样每个进程都有私有用户内存。第二，每个进程都将其内存视为从零开始的连续虚拟地址，而进程的物理内存可以是非连续的。第三，内核在用户地址空间的顶部都映射一个带有trampoline code的页面，从而在所有地址空间中显示同一个物理内存页面。

图3.4更详细地展现了xv6中正在执行的进程的用户内存布局。栈是一个单独的页面，和exec创建的初始内容一起显示。包含命令行参数的字符串，以及指向它们的指针数组，位于栈的顶部。下面是允许程序从main开始的值，就好像函数main(argc,argv)刚刚被调用一样。

为了检测到用户栈溢出，xv6清除掉了栈下面那一页面的PTE_U标志位，将这一页变为无法访问，以此来作为保护页面。如果用户栈溢出并且进程尝试使用栈下面的地址，硬件会生成一个页面错误异常，因为在用户模式下运行的程序无法访问保护页面。一个真实的操作系统可能会在用户堆溢出时自动为其分配更多的内存。

##  3.7 Code: sbrk

Sbrk是一个进程用来缩小或增加它的内存的系统调用。它由函数 growproc(kernel/proc.c:253)实现。growproc调用uvmalloc或uvmdealloc，这取决于n是正还是负。uvmalloc(kernel/vm.c: 221)用kalloc分配物理内存，用mappages将PTEs添加到用户页表中。uvmdealloc调用uvmunmap(kernel/vm.c:166)，使用 walk来查找PTEs，以及调用kfree释放他们引用的物理内存。

Xv6使用页表不仅是为了告诉硬件如何映射用户虚拟地址，还是作为分配给该进程的物理内存页面的唯一记录。这就是为什么释放用户内存(在uvmunmap中)需要检查用户页表的原因。

##  3.8 Code: exec

Exec是创建用户地址空间的系统调用。它用存储在文件系统中的文件初始化地址空间的用户部分。Exec(kernel/exec.c: 13)使用namei(kernel/exec.c:26)打开使用二进制命名的路径，这在第8章中有解释。然后，它读取ELF头。xv6应用程序普遍使用ELF格式描述，ELF格式定义在(kernel/ELF.h)中。ELF二进制文件包括一个ELF头文件struct elfhdr(kernel/ELF.h: 6)，后面是一系列程序节头(program section headers)struct proghdr(kernel/ELF.h: 25)。每个proghdr描述一个必须加载到内存中的应用程序节；xv6程序只有一个程序节头，但其他系统可能有单独的指令和数据节。

第一步是检查文件是否可能包含ELF二进制文件。ELF二进制文件以一个四个字节的“魔法数字”：0x7F、‘e’、‘l’、‘f’或ELF_MAGIC(kernel/ELF.h: 3)开始。如果ELF头有正确的魔
法数字，exec就认为这个文件是符合要求的。

Exec用proc_pagetable(kernel/exec.c: 38)分配一个没有用户映射的新页表，用uvmalloc(kernel/exec.c: 52)为每个ELF段分配内存，用loadseg(kernel/exec.c: 10)将每个段加载到内存中。Loadseg使用walkaddr在已分配的内存中寻找物理地址，将ELF段的每个页面写入，同时还会调用readi从文件的inode中读数据。

用exec创建的第一个用户程序/init的程序节头如下:
```
# objdump -p _init
user/_init: file format elf64-littleriscv
Program Header:
    LOAD off 0x00000000000000b0 vaddr 0x0000000000000000
                                    paddr 0x0000000000000000 align 2**3
        filesz 0x0000000000000840 memsz 0x0000000000000858 flags rwx

    TACK off 0x0000000000000000 vaddr 0x0000000000000000
                                    paddr 0x0000000000000000 align 2**4
        filesz 0x0000000000000000 memsz 0x0000000000000000 flags rw-
```

程序节头的filesz可能小于memsz，这段间隙应该用0(用C的全局变量)填充，而不是从文件中读取。对于/init，filesz是2112 个字节，memsz是2136 个字节，因此uvmalloc分配的物理内存足以保存2136个字节，但是从文件/init只读取2112个字节。

现在exec需要分配并初始化用户栈。它只分配一个栈页面。Exec 将参数字符串一次一个地复制到栈顶部，并在ustack中记录指向它们的指针。它在传递给main的argv列表末尾放置一个空指针。ustack中的前三个条目是伪程序返回计数器(fake return program counter)、argc和argv指针。

Exec会在栈页面下方放置一个无法访问的页面，这样如果程序试图使用更多的页面就会出错。这个不可访问的页面还允许exec处理过大的参数；在这种情况下，copyout(kernel/vm.c:347)函数将注意到目标页面是不可访问的，会返回-1。exec使用copyout函数将参数复制到栈上。

在准备新内存映像的过程中，如果exec检测到类似无效程序段的错误，它将跳转到标签bad，释放新映像，并返回-1。Exec必须等待释放旧映像，直到确保系统调用成功: 如果旧映像丢失，系统调用不能返回-1。Exec中唯一的错误只会发生在映像的创建过程中。一旦映像完成，exec就可以提交到新的页表(kernel/exec.c:113)，并释放旧的页表(kernel/exec.c: 117)。

Exec将ELF文件中的字节加载到ELF文件指定的地址的内存中。用户或进程可以将他们想要的任何地址放入ELF文件。因此，exec是有风险的，因为ELF文件中的地址可能意外或故意引用内核。对于一个粗心大意的内核来说，其后果可能是崩溃，甚至是内核隔离机制被恶意破坏(例如，安全漏洞)。xv6执行了许多检查以避免这些风险。例如，如果(ph.vaddr + ph.memsz < ph.vaddr)检查和是否溢出。危险在于，用户可以构造一个ELF二进制文件，其中一个ph.vaddr指向用户选择的地址，而 ph.memsz 的大小足以使和溢出到0x1000，这看起来是一个有效值。在 xv6 的旧版本中，用户地址空间也包含内核(但在用户模式下不可读/可写)，用户可以选择一个与内核内存对应的地址，从而将数据从ELF二进制文件
复制到内核中。在RISC-V版本的xv6中，这种情况不可能发生，因为内核有自己独立的页表；loadseg加载到进程的页表中，而不内核的页表中。

内核开发人员很容易忽略一个关键的检查，现实中的内核有很长的缺少检查的历史，用户程序可以利用缺少检查来获得内核特权。xv6也没有做到能够完全避免用户数据进入到内核，恶意用户程序可以利用这些数据来绕过xv6的隔离。

##  3.9 Real world

像大多数操作系统一样，xv6使用分页硬件进行内存保护和映射。大多数操作系统通过结合分页和页面错误异常(我们将在第4章讨论)来使用分页，这比xv6复杂得多。

通过内核使用虚拟地址和物理地址之间的直接映射，以及假设在地址0x8000000处有物理RAM(内核期望加载的位置)，xv6 得到了简化。这适用于QEMU，但是在真实的硬件上，这是个坏主意；真实的硬件将RAM和设备放置在不可预测的物理地址上，因此(例
如)0x8000000处可能没有RAM，但xv6希望能够在这里存储内核。更严肃的内核设计利用页表将任意的硬件物理内存布局转化为可预测的内核虚拟地址布局。

RISC-V支持物理地址级别的保护，但xv6没有使用这个功能。

在内存大的机器上，使用RISC-V对“超级页面”的支持可能是更有用的。而当物理内存很小的时候，小页更有用，它允许系统在分配页面和向磁盘page-out时使用更精确的单位。例如，如果一个程序只使用8KB的内存，那么给它一个4MB的超级物理内存页面就是浪费。更大的页面适合具有更大内存的计算机，并且可以减少页表操作的开销。

xv6内核缺少一个类似malloc这样可以为小对象提供内存的分配器，这使得内核无法使用需要动态分配内存的复杂数据结构。

内存分配一直都是热门的话题，基本问题是：如何有效使用有限的内存和为未知的未来请求做准备。今天人们更关心速度而不是空间利用率。此外，一个更精细的内核可能会分配许多不同大小的小块，而不是(如xv6)仅仅分配4096字节的块；一个真正的内核分配器需要处理小块和大块的分配。








































