
[2.5 Process overview](#25-process-overview)

[2.6 Code: starting xv6, the first process and system call](#26-code-starting-xv6-the-first-process-and-system-call)

[2.7 Security Model](#27-security-model)

## 2.5 Process overview

xv6为每一个进程单独维护一个页表，这个页表就定义了进程的地址空间。如图2.3所示，是一个包含了进程的用户空间的地址空间，它从虚拟地址0开始。首先是指令，随后是全局变量，栈，最后是堆（根据需要，用户可以通过malloc动态的扩展堆）。有多个因素限制了进程地址空间的最大值：Risc-V架构下的指针是64位；硬件只使用低39位来在页表中寻找虚拟地址；xv6只使用了39位中的38位。因此，最大虚拟地址为$2^{38}-1=$ 0x3fffffffff,在kernel/riscv.h:363中被定义为MAXVA。在地址空间的最高地址处，xv6为*trampoline*保留了一页，也保留了一页来映射进程的*trapframe*。xv6通过这两页来进入内核以及退出内核；*trampoline*这一页包含了进入和退出内核的代码；对*trapframe*的映射是必要的，它可以保存/恢复用户进程的状态，正如我们将在第 4 章中解释的那样。

Xv6内核为每个进程维护许多状态片段，它将这些状态收集到一个结构体proc(kernel/proc.h:86)中。一个进程最重要的内核状态片段是它的页表、内核栈和运行状态。我们将使用符号p->xxx来引用proc结构体中的元素；例如，p->pagetable是指向进程的页表的指针。

每个进程都有一个执行线程(简称线程)来执行进程的指令。一个线程可以被挂起，然后被恢复。为了在进程之间透明地切换，内核挂起当前正在运行的线程并恢复另一个进程的线程。线程的大部分状态(本地变量，函数调用返回地址)都存储在线程的栈中。每个进程都有两个栈: 一个用户栈和一个内核栈(p->kstack)。当进程执行用户指令时，只有它的用户栈在使用，而它的内核栈是空的。当进程进入内核(系统调用或中断)时，内核代码在进程的内核堆栈上执行; 当进程在内核中时，其用户栈仍然包含已保存的数据，但不会被主动使用。进程的线程在主动使用用户栈和内核栈之间交替。内核栈是独立的(被保护起来，远离用户代码) ，因此即使进程破坏了它的用户栈，内核也可以执行。

进程可以通过执行RISC-V的ecall指令进行系统调用。这条指令提升了硬件特权级别，并将程序计数器改为内核定义的入口点。入口点的代码切换到内核栈并执行内核指令来实现系统调用。当系统调用完成时，内核切换回用户栈，并通过调用sret指令返回用户空间，这降低了硬件特权级别，继续执行系统调用指令之后的那条用户指令。进程的线程可以在内核中“阻塞”以等待I/O，并在I/O完成后继续刚才暂停的工作。

p->state指示了进程是否已被分配、准备运行、运行、等待I/O或退出。

P->pagetable保存进程的页表，其格式符合RISC-V的硬件要求。Xv6让分页硬件在用户空间执行进程时使用进程的p->pagetable。一个进程的页表也可以作为分配给进程的物理页面地址的记录。

总之，进程捆绑了两个设计思想: 通过地址空间来给进程一种独自占有内存的错觉；通过一个线程来给进程一种独占CPU的错觉。在xv6中，一个进程由一个地址空间和一个线程组成。在真实的操作
系统中，一个进程可能有多个线程来利用多个CPU。

## 2.6 Code: starting xv6, the first process and system call

为了使xv6更具体，我们将概述内核如何启动和运行第一个进程。接下来的章节将更详细地描述在这个概述中出现的机制。

当RISC-V计算机启动时，它初始化自己并运行一个引导加载程序，该引导加载程序存储在只读内存中。引导加载程序将xv6内核加载到内存中。然后，在机器模式下，CPU 从_entry(kernel/entry.s:7)开始执行xv6。此时RISC-V分页硬件并没有工作:虚拟地址直接映射到物理地址。

加载器将xv6内核加载到物理地址0x80000000的内存中。它把内核放在0x8000000而不是0x0的原因是因为地址范围 0x0:0x8000000包含I/O设备。

_entry中的指令设置了一个栈，以便xv6可以运行c代码。xv6 在start.c(kernel/start.c:11)文件中声明了初始栈stack0的空间。_entry处的代码用堆栈顶部的地址stack0+4096 初始化栈指针寄存器sp，因为RISC-V架构下的栈向低地址增长。现在内核有了堆栈，_entry调用c代码(kernel/start.c:21)。

函数start执行一些只允许在机器模式下进行的配置，然后切换到管理模式。为了进入管理模式，RISC-V提供了指令mret。这个指令最常用于从上一个调用从管理模式返回到机器模式。虽然start不是从这样的调用中返回，但它仍当作是从这样的调用中返回的，并设置一些东西: 它将mstatus寄存器中保存的模式标志设置为管理模式；它将main的地址写入寄存器mepc来作为返回地址；将0 写入页表寄存器satp，在管理模式中禁用虚拟地址转换；并将所有中断和异常委托给管理模式。

在进入管理模式之前，start还要执行一项任务：它对时钟芯片进行编程以生成计时器中断。这些都处理完毕，start通过调用 mret“返回”到管理模式。这会将程序计数器置为为main的地址(kernel/main.c: 11)

在main(kernel/main.c:11)初始化几个设备和子系统之后，它通过调用userinit(kernel/proc.c:226)创建第一个进程。第一个进程执行一个用RISC-V汇编写的小程序，使用xv6进行第一次系统调用。initcode.S(user/initcode.S:3)将exec的系统调用号SYS_EXEC(kernel/syscall.h:8)加载到寄存器a7中，然后调用ecall重新进入内核。

内核使用寄存器a7中的数字来调用syscall(kernel/syscall.c: 133)中的系统调用。系统调用表(kernel/syscall.c: 108)将SYS_EXEC映射到内核调用的sys_exec。正如我们在第1章中看到的，exec用一个新程序(在本例中是/init)替换了当前进程的内存和寄存器。

一旦内核完成了exec，它将返回到/init进程中的用户空间。Init(user/Init.c:15)在需要的时候创建一个新的控制台设备文件，然后打开它的文件描述符0、1、2。然后在控制台上启动一个shell。系统启动了。

## 2.7 Security Model

你可能想知道操作系统是如何处理错误或恶意代码的。因为处理恶意软件比处理意外的错误更加困难，所以将这个话题视为与安全有关是合理的。下面是一个关于操作系统设计中典型的安全假设和目标的宏观观点。

操作系统必须假设一个进程的用户级代码会破坏内核或其他进程。用户代码可能会尝试在其允许的地址空间之外引用指针；它可能尝试执行任何RISC-V指令，甚至那些不是用户代码的指令；它可能尝试读写任何RISC-V控制寄存器；它可能尝试直接访问设备硬件；它可能向系统调用传递“巧妙”的值，来使内核崩溃。内核的目标是限制每个用户进程，使它们所能做的就是读/写/执行它自己的用户内存，使用32个通用RISC-V寄存器，并以系统调用允许的方式影响内核和其他进程。内核必须阻止任何其他操作。这是内核设计中的一个必然要求。

对内核自身的代码我们的期望完全不同。内核代码被认为是由无恶意和谨慎的程序员编写的。内核代码应该是没有bug的，当然也不能包含任何恶意的东西。这个假设影响了我们分析内核代码
的方式。例如，有许多内核函数(例如自旋锁) ，如果内核代码不正确地使用它们，就会导致严重的问题。当检查任何一段特定的内核代码时，我们都试图相信它的行为是正确的。我们假设内核代码通常是编写正确的，并遵循相关规则。在硬件层面，RISC-V CPU、RAM、磁盘等被假定为按照文档中描述的那样运行，没有硬件错误。

当然，在现实生活中，事情并不是那么简单。我们很难去防止一些代码通过消耗受内核保护的资源(磁盘空间、CPU时间、进程表槽等)而使系统无法使用(或导致系统恐慌)。编写无缺陷代码或设计无缺陷硬件通常是不可能的；如果恶意用户代码的编写者知道内核或硬件缺陷，他们就会利用这些缺陷。我们可以在内核中进行如下设计来防止bug：诊断、类型检查、栈保护页面等等。最后，用户代码和内核代码之间的区别有时是模糊的: 一些特权用户级进程可以提供必要的服务，有效地成为操作系统的一部分，在一些操作系统中，特权用户代码可以在内核中插入新的代码(与Linux的可加载内核模块一样)。











