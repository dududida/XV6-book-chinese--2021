
- [Chapter 2](#chapter-2)
  - [2.5 Process overview](#25-process-overview)
  - [2.6 Code: starting xv6, the first process and system call](#26-code-starting-xv6-the-first-process-and-system-call)
  - [2.7 Security Model](#27-security-model)
- [Chapter 3 Page table](#chapter-3-page-table)
  - [3.1 Paging hardware](#31-paging-hardware)
  - [3.2 Kernel address space](#32-kernel-address-space)
  - [3.3 Code: creating an address space](#33-code-creating-an-address-space)
  - [3.4 Physical memory allocation](#34-physical-memory-allocation)
  - [3.5 Code: Physical memory allocator](#35-code-physical-memory-allocator)
  - [3.6 Process address space](#36-process-address-space)
  - [3.7 Code: sbrk](#37-code-sbrk)
  - [3.8 Code: exec](#38-code-exec)
  - [3.9 Real world](#39-real-world)
- [Chapter 4 Traps and syscalls](#chapter-4-traps-and-syscalls)
  - [4.1 RISC-V trap machinery](#41-risc-v-trap-machinery)
  - [4.2 Traps from user space](#42-traps-from-user-space)
  - [4.3 Code: Calling system calls](#43-code-calling-system-calls)
  - [4.4  Code: System call arguments](#44--code-system-call-arguments)
  - [4.5 Traps from kernel space](#45-traps-from-kernel-space)
  - [4.6 Page-fault exceptions](#46-page-fault-exceptions)
  - [Real world](#real-world)
- [Chapter 5 Interrupts and device drivers](#chapter-5-interrupts-and-device-drivers)



# Chapter 2

##  2.5 Process overview

xv6为每一个进程单独维护一个页表，这个页表就定义了进程的地址空间。如图2.3所示，是一个包含了进程的用户空间的地址空间，它从虚拟地址0开始。首先是指令，随后是全局变量，栈，最后是堆（根据需要，用户可以通过malloc动态的扩展堆）。有多个因素限制了进程地址空间的最大值：Risc-V架构下的指针是64位；硬件只使用低39位来在页表中寻找虚拟地址；xv6只使用了39位中的38位。因此，最大虚拟地址为$2^{38}-1=$ 0x3fffffffff,在kernel/riscv.h:363中被定义为MAXVA。在地址空间的最高地址处，xv6为*trampoline*保留了一页，也保留了一页来映射进程的*trapframe*。xv6通过这两页来进入内核以及退出内核；*trampoline*这一页包含了进入和退出内核的代码；对*trapframe*的映射是必要的，它可以保存/恢复用户进程的状态，正如我们将在第 4 章中解释的那样。

Xv6内核为每个进程维护许多状态片段，它将这些状态收集到一个结构体proc(kernel/proc.h:86)中。一个进程最重要的内核状态片段是它的页表、内核栈和运行状态。我们将使用符号p->xxx来引用proc结构体中的元素；例如，p->pagetable是指向进程的页表的指针。

每个进程都有一个执行线程(简称线程)来执行进程的指令。一个线程可以被挂起，然后被恢复。为了在进程之间透明地切换，内核挂起当前正在运行的线程并恢复另一个进程的线程。线程的大部分状态(本地变量，函数调用返回地址)都存储在线程的栈中。每个进程都有两个栈: 一个用户栈和一个内核栈(p->kstack)。当进程执行用户指令时，只有它的用户栈在使用，而它的内核栈是空的。当进程进入内核(系统调用或中断)时，内核代码在进程的内核堆栈上执行; 当进程在内核中时，其用户栈仍然包含已保存的数据，但不会被主动使用。进程的线程在主动使用用户栈和内核栈之间交替。内核栈是独立的(被保护起来，远离用户代码) ，因此即使进程破坏了它的用户栈，内核也可以执行。

进程可以通过执行RISC-V的ecall指令进行系统调用。这条指令提升了硬件特权级别，并将程序计数器改为内核定义的入口点。入口点的代码切换到内核栈并执行内核指令来实现系统调用。当系统调用完成时，内核切换回用户栈，并通过调用sret指令返回用户空间，这降低了硬件特权级别，继续执行系统调用指令之后的那条用户指令。进程的线程可以在内核中“阻塞”以等待I/O，并在I/O完成后继续刚才暂停的工作。

p->state指示了进程是否已被分配、准备运行、运行、等待I/O或退出。

P->pagetable保存进程的页表，其格式符合RISC-V的硬件要求。Xv6让分页硬件在用户空间执行进程时使用进程的p->pagetable。一个进程的页表也可以作为分配给进程的物理页面地址的记录。

总之，进程捆绑了两个设计思想: 通过地址空间来给进程一种独自占有内存的错觉；通过一个线程来给进程一种独占CPU的错觉。在xv6中，一个进程由一个地址空间和一个线程组成。在真实的操作
系统中，一个进程可能有多个线程来利用多个CPU。

##  2.6 Code: starting xv6, the first process and system call

为了使xv6更具体，我们将概述内核如何启动和运行第一个进程。接下来的章节将更详细地描述在这个概述中出现的机制。

当RISC-V计算机启动时，它初始化自己并运行一个引导加载程序，该引导加载程序存储在只读内存中。引导加载程序将xv6内核加载到内存中。然后，在机器模式下，CPU 从_entry(kernel/entry.s:7)开始执行xv6。此时RISC-V分页硬件并没有工作:虚拟地址直接映射到物理地址。

加载器将xv6内核加载到物理地址0x80000000的内存中。它把内核放在0x8000000而不是0x0的原因是因为地址范围 0x0:0x8000000包含I/O设备。

_entry中的指令设置了一个栈，以便xv6可以运行c代码。xv6 在start.c(kernel/start.c:11)文件中声明了初始栈stack0的空间。_entry处的代码用堆栈顶部的地址stack0+4096 初始化栈指针寄存器sp，因为RISC-V架构下的栈向低地址增长。现在内核有了堆栈，_entry调用c代码(kernel/start.c:21)。

函数start执行一些只允许在机器模式下进行的配置，然后切换到管理模式。为了进入管理模式，RISC-V提供了指令mret。这个指令最常用于从上一个调用从管理模式返回到机器模式。虽然start不是从这样的调用中返回，但它仍当作是从这样的调用中返回的，并设置一些东西: 它将mstatus寄存器中保存的模式标志设置为管理模式；它将main的地址写入寄存器mepc来作为返回地址；将0 写入页表寄存器satp，在管理模式中禁用虚拟地址转换；并将所有中断和异常委托给管理模式。

在进入管理模式之前，start还要执行一项任务：它对时钟芯片进行编程以生成计时器中断。这些都处理完毕，start通过调用 mret“返回”到管理模式。这会将程序计数器置为为main的地址(kernel/main.c: 11)

在main(kernel/main.c:11)初始化几个设备和子系统之后，它通过调用userinit(kernel/proc.c:226)创建第一个进程。第一个进程执行一个用RISC-V汇编写的小程序，使用xv6进行第一次系统调用。initcode.S(user/initcode.S:3)将exec的系统调用号SYS_EXEC(kernel/syscall.h:8)加载到寄存器a7中，然后调用ecall重新进入内核。

内核使用寄存器a7中的数字来调用syscall(kernel/syscall.c: 133)中的系统调用。系统调用表(kernel/syscall.c: 108)将SYS_EXEC映射到内核调用的sys_exec。正如我们在第1章中看到的，exec用一个新程序(在本例中是/init)替换了当前进程的内存和寄存器。

一旦内核完成了exec，它将返回到/init进程中的用户空间。Init(user/Init.c:15)在需要的时候创建一个新的控制台设备文件，然后打开它的文件描述符0、1、2。然后在控制台上启动一个shell。系统启动了。

##  2.7 Security Model

你可能想知道操作系统是如何处理错误或恶意代码的。因为处理恶意软件比处理意外的错误更加困难，所以将这个话题视为与安全有关是合理的。下面是一个关于操作系统设计中典型的安全假设和目标的宏观观点。

操作系统必须假设一个进程的用户级代码会破坏内核或其他进程。用户代码可能会尝试在其允许的地址空间之外引用指针；它可能尝试执行任何RISC-V指令，甚至那些不是用户代码的指令；它可能尝试读写任何RISC-V控制寄存器；它可能尝试直接访问设备硬件；它可能向系统调用传递“巧妙”的值，来使内核崩溃。内核的目标是限制每个用户进程，使它们所能做的就是读/写/执行它自己的用户内存，使用32个通用RISC-V寄存器，并以系统调用允许的方式影响内核和其他进程。内核必须阻止任何其他操作。这是内核设计中的一个必然要求。

对内核自身的代码我们的期望完全不同。内核代码被认为是由无恶意和谨慎的程序员编写的。内核代码应该是没有bug的，当然也不能包含任何恶意的东西。这个假设影响了我们分析内核代码
的方式。例如，有许多内核函数(例如自旋锁) ，如果内核代码不正确地使用它们，就会导致严重的问题。当检查任何一段特定的内核代码时，我们都试图相信它的行为是正确的。我们假设内核代码通常是编写正确的，并遵循相关规则。在硬件层面，RISC-V CPU、RAM、磁盘等被假定为按照文档中描述的那样运行，没有硬件错误。

当然，在现实生活中，事情并不是那么简单。我们很难去防止一些代码通过消耗受内核保护的资源(磁盘空间、CPU时间、进程表槽等)而使系统无法使用(或导致系统恐慌)。编写无缺陷代码或设计无缺陷硬件通常是不可能的；如果恶意用户代码的编写者知道内核或硬件缺陷，他们就会利用这些缺陷。我们可以在内核中进行如下设计来防止bug：诊断、类型检查、栈保护页面等等。最后，用户代码和内核代码之间的区别有时是模糊的: 一些特权用户级进程可以提供必要的服务，有效地成为操作系统的一部分，在一些操作系统中，特权用户代码可以在内核中插入新的代码(与Linux的可加载内核模块一样)。


# Chapter 3 Page table

页表是最常用的机制，通过它，操作系统为每个进程提供自己的私有地址空间和内存。页表决定了内存地址的含义，以及物理内存的哪些部分可以被访问。它允许xv6隔离不同进程的地址空间，并将它们映射在同一个物理内存上。页表是一种流行的设计，因为它允许操作系统在一定程度上间接性地施展一些策略。例如：在几个地址空间中映射相同的内存(trampoline page) ，并使用一个未映射的页面保护内核和用户栈。本章的其余部分解释了RISC-V硬件提供的页表以及xv6如何使用它们。

## 3.1 Paging hardware

提醒，RISC-V指令(用户和内核)都操作虚拟地址。机器的RAM，或者说物理内存，是用物理地址索引的。RISC-V页表硬件通过将每个虚拟地址映射到一个物理地址来连接这两种地址。

Xv6在RISC-V的Sv39格式上运行，这意味着只使用64位虚拟地址的低39位，而不使用高25位。在这个sv39格式中，RISC-V页表在逻辑上是由$2^{27}$个页表条目(PTEs，page table entrys)组成的数组。每个PTE包含一个44位的物理页号(PPN，physical page number)和一些标志位。分页硬件通过使用39位中的高27位对页表进行索引来转换虚拟地址，从而找到一个 PTE，并生成一个56位物理地址，其高44位来自PTE中的PPN，其低12位来自原始虚拟地址。图3.1显示了这个过程，页表的逻辑视图是一个简单的PTEs数组（图3.2提供了更完整的描绘）。一个页表为操作系统提供了对4096($2^{12}$)个字节大小对齐的块进行虚拟到物理地址转换的控制。这样的块被称为页面。

在Sv39 RISC-V中，虚拟地址的前25位不用于转换。物理地址也有增长的空间: PTE格式的物理页号还有增长10位的空间。RISC-V的设计者根据技术预测选择了这些数字。$2^{39}$字节是512GB，这样大的地址空间对于在Risc-V机器上运行的应用来说应该是足够的。$2^{56}$大小的物理地址上限对于适应近期的I/O设备和DRAM芯片也是足够的。如果需要更大的地址，Risc-V的设计者们已经定义了48位的虚拟地址。

如图3.2所示，RISC-V CPU通过三个步骤将虚拟地址转换为物理地址。一个页表以三级树的形式存储在物理内存中。树的根是一个4096字节的页表页面，其中包含512个PTE，这些PTE包含了树的下一级别页表的物理地址。每个页面都包含512个PTE，用于树的最后一级。分页硬件使用27位中的高9位在根页表页面中选择 PTE，中间的9位在树的下一级别的页表中选择PTE，低的9位选择最终的PTE。(在Sv48 RISC-V中，页表有四个级别，虚拟地址索
引的39位到47位进入顶级。)

如果转换地址所需的三个PTE中的任何一个不存在，则分页硬件将引发页面错误异常，将其留给内核处理异常(参见第 4 章)。

与图3.1的单级设计相比，图3.2的三级结构记录PTEs会更加节省内存。在大范围的虚拟地址没有映射的情况下，三级结构可以省略整个页面目录。例如，如果一个应用程序只使用从地址零开始的几个页面，那么顶级页面目录的条目1到511是无效的，内核不必为 511个中间页面目录分配这些页面。此外，内核也不需要为底层的511个中间页目录分配页面。因此，在这个例子中，三级设计为中间页目录节省了511页，为底层页目录节省了$511\times 512$页。

虽然CPU在执行加载或存储指令时使用硬件中的三级结构，但是三级结构的潜在缺点是CPU必须从内存中加载三个PTE，才能将加载/存储指令中的虚拟地址转换为物理地址。为了避免吗从物理内存加载PTEs的成本，RISC-V CPU 在Translation Look-aside Buffer(TLB)中缓存页表条目。

每个PTE包含标志位，它告诉分页硬件如何使用相关的虚拟地址。PTE_V指示PTE是否存在: 如果没有设置，对页面的引用将导致异常(即不允许)。PTE_R控制指令是否被允许读取到页面。PTE_W控制是否允许指令写入页面。PTE_X控制CPU是否可以将页面内容解释为指令并执行它们。PTE_U控制是否允许用户模式下的指令访问页面；如果未设置PTE_U，则PTE只能在管理模式下使用。图3.2 展示了它是如何工作的。标志和所有其他与页面硬件相关的结构在(kernel/riscv.h)中定义。

要告诉硬件使用页表，内核必须将根页表页的物理地址写入satp寄存器。每个CPU都有自己的satp。一个 CPU 将使用它自己的 satp指向的页表来转换后续指令生成的所有地址。每个 CPU 都有自己的satp，这样不同的 CPU 可以运行不同的进程，每个进程
都有自己的页表所描述的私有地址空间。

通常一个内核会将所有的物理内存映射到它的页表中，这样它就可以使用加载/存储指令读写物理内存中的任何位置。由于页面目录位于物理内存中，内核可以使用标准存储指令写入 PTE 的虚拟地址，从而对页面目录中的 PTE 内容进行编程。

关于术语的几点注意事项。物理内存是指 DRAM 中的存储单元。一个字节的物理内存有一个地址，叫做物理地址。指令只使用虚拟地址，分页硬件将其转换为物理地址，然后发送到 DRAM 硬件进行读取/写入。与物理内存和虚拟地址不同，虚拟内存不是一个物理对象，而是指内核提供的用于管理物理内存和虚拟地址的抽象和机制的集合。

##  3.2 Kernel address space

Xv6 每个进程维护一个页表，描述每个进程的用户地址空间，外加一个描述内核地址空间的单页表。内核配置其地址空间的布局，以便在可预测的虚拟地址上访问物理内存和各种硬件资源。图 3.3 显示了这种布局如何将内核虚拟地址映射到物理地址。文件(kernel/memlayout.h)声明了 xv6 内核内存布局的常量。

QEMU 模拟了一台包含 RAM (物理内存)的计算机，从物理地址 0x8000000开始，至少持续到0x86400000，xv6 称之为PHYSTOP。QEMU 模拟还包括 I/O 设备，如磁盘接口。QEMU将设备接口公开给软件作为内存映射控制寄存器，这些寄存器位于物理地址空间的 0x8000000 以下。内核可以通过读写这些特殊的物理地址与设备交互；这些读写通信是与设备硬件而不是RAM。第四章解释了xv6如何与设备交互。

内核使用“直接映射”获得 RAM 和内存映射设备寄存器，即在与物理地址相等的虚拟地址上映射资源。例如，内核本身在虚拟地址空间和物理内存中都位于KERNBASE = 0x80000000。直接映射简化了读写物理内存的内核代码。例如，当 fork 为子进程分配用户
内存时，分配器返回该内存的物理地址； fork 在将父进程的用户内存复制到子进程时，直接将该地址用作虚拟地址。

有一些内核虚拟地址不是直接映射的：

- Trampoline page。它被映射到虚拟地址空间的顶部；用户页表也有相同的映射。第4章讨论了Trampoline page的作用，我们在这里看到了一个有趣的页表用例；一个物理页面(包含着Trampoline code)在内核的虚拟地址空间中被映射了两次: 一次在虚拟地址空间的顶部，一次通过直接映射。

- Kernel stack pages。每个进程都有自己的内核栈，这个栈被映射到地址比较高的地方，因此 xv6 可以在它下面保留一个未映射的保护页面。保护页面的 PTE 无效(即未设置 PTE_V) ，因此如果内核栈溢出，它可能会导致异常，内核将会panic。但如果没有保护页面，溢出的栈会覆盖其他内核内存，导致不正确的操作。显然panic crash是更好的选择。

内核既可以通过向高地址映射使用其栈，也可以通过直接映射的地址访问内核。另一种设计是只有直接映射，并在直接映射的地址使用栈。然而，在这种设计下，提供保护页面就需要取消虚拟地址映射，否则这些虚拟地址会引用物理内存，这样就很难用了。

内核用权限PTE_R和PTE_X映射Trampoline页面和内核文本页面。内核从这些页面读取和执行指令。内核用权限PTE_R和PTE_W映射其他页面，这样它就可以读写这些页面中的内存。注意，保护页面的映射是无效的。

##  3.3 Code: creating an address space

大部分用于操作地址空间和页表的xv6代码都在vm.c中(kernel/vm.c:1)。中心数据结构是pagetable_t，它实际上是一个指向 RISC-V 根页表页面的指针；一个pagetable_t可以是内核页表，也可以是每个进程的页表之一。中心函数是walk，它为一
个虚拟地址找到PTE，以及mappages，即为新的映射分配PTE。以kvm开头的函数操作内核页表；以uvm开头的函数操作用户页表； 其他函数服务于两者。copyout和copyin复制数据到用户虚拟地址或从用户虚拟地址复制数据，这些数据作为系统调用参数提供；copyin/out在 vm.c中，是因为它们需要显式地翻译这些地址，以便找到相应的物理内存。

在机器启动的最初阶段，main调用kvminit(kernel/vm.c: 54)来使用kvmmake (kernel/vm.c: 20)创建内核的页表。这个调用发生在xv6启用RISC-V 上的分页之前，因此地址直接指向物理内存。Kvmmake首先分配一个物理内存页面来保存根页表页面。然后它调用kvmmap来完成内核需要的映射。映射包括内核的指令和数据，直到PHYSTOP区域的物理内存，以及实际上是描述设备的内存范围。Proc_mapstacks(kernel/proc.c:33)为每个进程分配一个内核栈。它调用kvmmap将每个堆栈映射到KSTACK生成的虚拟地址，这样就为栈保护页面留下了空间。

kvmmap(kernel/vm.c:127)调用mappages(kernel/vm.c:138) ，它将一个虚拟地址范围的映射安装到一个页表中，并将其映射到相应的物理地址范围。它对范围内的每个虚拟地址按页面间隔分别执行此操作。对于每个要映射的虚拟地址，映射调用遍历以找到该地址的PTE地址。然后，它初始化PTE以保存相关的物理页好、所需的权限(PTE_W、PTE_X、PTE_R) ，以及PTE_V以标记PTE为有效(kernel/vm.c:153)。

walk(kernel/vm.c:81)在查找PTE虚拟地址时模拟 RISC-V 分页硬件(参见图 3.2)。walk同时使用3级页表的索引。它使用每个级别的9位虚拟地址来查找下一级别页表或最终页(kernel/vm.c: 87)的PTE。如果 PTE 无效，则所需的页面尚未分配；如果设置了alloc参数，则 walk 将分配一个新的页面，并将其物理地址放在PTE中。它返回树中最底层的PTE地址(kernel/vm.c: 97)。

上面的代码依赖于直接映射到内核虚拟地址空间的物理内存。例如，当walk进入下一级页表时，它从 PTE (kernel/vm.c: 89)中提取下一级别页表的(物理)地址，然后使用该地址作为虚拟地址来提取下一级别下的PTE(kernel/vm.c: 87)。

main调用kvminithart(kernel/vm.c: 62)来安装内核页表。它将根页表页面的物理地址写入寄存器satp。在这之后，CPU 将使用内核页表转换地址。由于内核使用identity mapping，下一条指令的现在虚拟地址将映射到正确的物理内存地址。

每个RISC-V CPU都在快表(TLB)中缓存页表条目，当xv6更改页表
时，它必须告诉CPU使相应缓存的TLB条目无效。如果没有，那么在以后的某个时候，TLB可能会使用一个旧的缓存映射，指向一个物理页面，这个页面在此期间已经被分配给另一个进程，因此，一个进程可能会在另一个进程的内存上读写。RISC-V 有一个指令 sfence.vma 可以刷新当前 CPU 的 TLB。Xv6 在重新加载 satp寄存器之后用 kvminithart 执行 sfence.vma，并在trampoli code中切换到用户页表，这个切换是在返回到用户空间之前完成的(kernel/trampoline.S:79)。

为了避免刷新全部的TLB条目，RISC-V CPU支持地址空间标识符(ASIDs)。内核可以只刷新特定地址空间的 TLB 条目。

##  3.4 Physical memory allocation

内核必须在运行时为页表、用户内存、内核栈和管道缓冲区分配和释放物理内存。Xv6 使用内核空间和PHYSTOP之间的物理内存进行运行时分配(参考图 3.3)。它一次分配和释放整个4096字节的页面。它通过链表来跟踪哪些页面是空闲的。分配是从链表中删除一个页面；释放是将释放的页面添加到链表中。

##  3.5 Code: Physical memory allocator

分配器位于kalloc.c(kernel/kalloc.c: 1)。分配器的数据结构是一个可用于分配的物理内存页面的空闲链表。每个空闲页面对应的的链表元素是一个struct run(kernel/kalloc.c: 17)。分配器从哪里获得内存来保存这个数据结构呢？它将每个空闲页面的run struct就存储在对应的空闲页面中，因为空闲页面中也不存放其他东西。空闲链表由自旋锁保护(kernel/kalloc.c: 21-24)。链表和锁被包装在一个结构体中，以表明这个锁保护该结构中的字段。现在，我们暂时先忽略锁的获取和释放；第6章再来详细研究锁。

函数main调用kinit来初始化分配器(kernel/kalloc.c:27)。kinit初始化空闲链表来保存介于内核空间和PHYSTOP之间的每个页面。xv6通过解析硬件提供的配置信息来确定有多少物理内存可用。xv6假设机器有128MB内存。kinit调用freerange，通过对每页调用kfree来为空闲链表添加内存。PTE只能引用在4096字节边界上对齐的物理地址(是4096的倍数)，因此freerange使用 PGROUNDUP来确保它只释放对齐的物理地址。分配器开始时
并没有内存可分配；是这些对kfree的调用给了它一些内存空间。

分配器有时将地址视为整数，以便对它们执行算术操作(例如，在 freerange中遍历所有页面)，有时将地址用作读写内存的指针(例如，操作存储在每个页面中的run struct)；这种对地址的双重使用是分配器代码充满C类型转换的主要原因。另一个原因是释放和分配从本质上改变了内存的类型。

函数kfree(kernel/kalloc.c: 47)首先将释放的内存中的每个字节设置为值1。这将导致在释放内存后使用内存的代码(使用“悬空引用”)只能读取到无用信息，而不是旧的有效内容；目的是希望这种错误代码更快地停下。然后kfree将页面从头部插入到空闲链表中：它将pa转换为struct run的指针，在r->next中记录空闲链表之前的起始地址，并将空闲链表设置为等于r(译者注：就是链表的头插法嘛，kalloc就是从头部取)。kalloc删除并返回空闲链表中的第一个元素。

##  3.6 Process address space

每个进程都有一个单独的页表，当 xv6 在进程之间切换时，它也会改变页表。如图 2.3 所示，一个进程的用户内存从虚拟地址零开始，可以增长到MAXVA(kernel/riscv.h:360)，允许一个进程在原则上寻址256GB的内存。

当进程向xv6请求更多的用户内存时，xv6 首先使用kalloc来分配物理页面。然后，它将PTEs添加到进程的页表中，指向新的物理页面。xv6在这些PTEs中设置PTE_W、PTE_X、PTE_R、PTE_U 和PTE_V标志。大多数进程不使用整个用户地址空间；xv6在未使用的PTE中保留PTE_V。

我们在这里列举一些使用页表的好处。第一，不同进程的页表将用户地址转换为不同的物理内存页面，这样每个进程都有私有用户内存。第二，每个进程都将其内存视为从零开始的连续虚拟地址，而进程的物理内存可以是非连续的。第三，内核在用户地址空间的顶部都映射一个带有trampoline code的页面，从而在所有地址空间中显示同一个物理内存页面。

图3.4更详细地展现了xv6中正在执行的进程的用户内存布局。栈是一个单独的页面，和exec创建的初始内容一起显示。包含命令行参数的字符串，以及指向它们的指针数组，位于栈的顶部。下面是允许程序从main开始的值，就好像函数main(argc,argv)刚刚被调用一样。

为了检测到用户栈溢出，xv6清除掉了栈下面那一页面的PTE_U标志位，将这一页变为无法访问，以此来作为保护页面。如果用户栈溢出并且进程尝试使用栈下面的地址，硬件会生成一个页面错误异常，因为在用户模式下运行的程序无法访问保护页面。一个真实的操作系统可能会在用户堆溢出时自动为其分配更多的内存。

##  3.7 Code: sbrk

Sbrk是一个进程用来缩小或增加它的内存的系统调用。它由函数 growproc(kernel/proc.c:253)实现。growproc调用uvmalloc或uvmdealloc，这取决于n是正还是负。uvmalloc(kernel/vm.c: 221)用kalloc分配物理内存，用mappages将PTEs添加到用户页表中。uvmdealloc调用uvmunmap(kernel/vm.c:166)，使用 walk来查找PTEs，以及调用kfree释放他们引用的物理内存。

Xv6使用页表不仅是为了告诉硬件如何映射用户虚拟地址，还是作为分配给该进程的物理内存页面的唯一记录。这就是为什么释放用户内存(在uvmunmap中)需要检查用户页表的原因。

##  3.8 Code: exec

Exec是创建用户地址空间的系统调用。它用存储在文件系统中的文件初始化地址空间的用户部分。Exec(kernel/exec.c: 13)使用namei(kernel/exec.c:26)打开使用二进制命名的路径，这在第8章中有解释。然后，它读取ELF头。xv6应用程序普遍使用ELF格式描述，ELF格式定义在(kernel/ELF.h)中。ELF二进制文件包括一个ELF头文件struct elfhdr(kernel/ELF.h: 6)，后面是一系列程序节头(program section headers)struct proghdr(kernel/ELF.h: 25)。每个proghdr描述一个必须加载到内存中的应用程序节；xv6程序只有一个程序节头，但其他系统可能有单独的指令和数据节。

第一步是检查文件是否可能包含ELF二进制文件。ELF二进制文件以一个四个字节的“魔法数字”：0x7F、‘e’、‘l’、‘f’或ELF_MAGIC(kernel/ELF.h: 3)开始。如果ELF头有正确的魔
法数字，exec就认为这个文件是符合要求的。

Exec用proc_pagetable(kernel/exec.c: 38)分配一个没有用户映射的新页表，用uvmalloc(kernel/exec.c: 52)为每个ELF段分配内存，用loadseg(kernel/exec.c: 10)将每个段加载到内存中。Loadseg使用walkaddr在已分配的内存中寻找物理地址，将ELF段的每个页面写入，同时还会调用readi从文件的inode中读数据。

用exec创建的第一个用户程序/init的程序节头如下:
```
# objdump -p _init
user/_init: file format elf64-littleriscv
Program Header:
    LOAD off 0x00000000000000b0 vaddr 0x0000000000000000
                                    paddr 0x0000000000000000 align 2**3
        filesz 0x0000000000000840 memsz 0x0000000000000858 flags rwx

    TACK off 0x0000000000000000 vaddr 0x0000000000000000
                                    paddr 0x0000000000000000 align 2**4
        filesz 0x0000000000000000 memsz 0x0000000000000000 flags rw-
```

程序节头的filesz可能小于memsz，这段间隙应该用0(用C的全局变量)填充，而不是从文件中读取。对于/init，filesz是2112 个字节，memsz是2136 个字节，因此uvmalloc分配的物理内存足以保存2136个字节，但是从文件/init只读取2112个字节。

现在exec需要分配并初始化用户栈。它只分配一个栈页面。Exec 将参数字符串一次一个地复制到栈顶部，并在ustack中记录指向它们的指针。它在传递给main的argv列表末尾放置一个空指针。ustack中的前三个条目是伪程序返回计数器(fake return program counter)、argc和argv指针。

Exec会在栈页面下方放置一个无法访问的页面，这样如果程序试图使用更多的页面就会出错。这个不可访问的页面还允许exec处理过大的参数；在这种情况下，copyout(kernel/vm.c:347)函数将注意到目标页面是不可访问的，会返回-1。exec使用copyout函数将参数复制到栈上。

在准备新内存映像的过程中，如果exec检测到类似无效程序段的错误，它将跳转到标签bad，释放新映像，并返回-1。Exec必须等待释放旧映像，直到确保系统调用成功: 如果旧映像丢失，系统调用不能返回-1。Exec中唯一的错误只会发生在映像的创建过程中。一旦映像完成，exec就可以提交到新的页表(kernel/exec.c:113)，并释放旧的页表(kernel/exec.c: 117)。

Exec将ELF文件中的字节加载到ELF文件指定的地址的内存中。用户或进程可以将他们想要的任何地址放入ELF文件。因此，exec是有风险的，因为ELF文件中的地址可能意外或故意引用内核。对于一个粗心大意的内核来说，其后果可能是崩溃，甚至是内核隔离机制被恶意破坏(例如，安全漏洞)。xv6执行了许多检查以避免这些风险。例如，如果(ph.vaddr + ph.memsz < ph.vaddr)检查和是否溢出。危险在于，用户可以构造一个ELF二进制文件，其中一个ph.vaddr指向用户选择的地址，而 ph.memsz 的大小足以使和溢出到0x1000，这看起来是一个有效值。在 xv6 的旧版本中，用户地址空间也包含内核(但在用户模式下不可读/可写)，用户可以选择一个与内核内存对应的地址，从而将数据从ELF二进制文件
复制到内核中。在RISC-V版本的xv6中，这种情况不可能发生，因为内核有自己独立的页表；loadseg加载到进程的页表中，而不内核的页表中。

内核开发人员很容易忽略一个关键的检查，现实中的内核有很长的缺少检查的历史，用户程序可以利用缺少检查来获得内核特权。xv6也没有做到能够完全避免用户数据进入到内核，恶意用户程序可以利用这些数据来绕过xv6的隔离。

##  3.9 Real world

像大多数操作系统一样，xv6使用分页硬件进行内存保护和映射。大多数操作系统通过结合分页和页面错误异常(我们将在第4章讨论)来使用分页，这比xv6复杂得多。

通过内核使用虚拟地址和物理地址之间的直接映射，以及假设在地址0x8000000处有物理RAM(内核期望加载的位置)，xv6 得到了简化。这适用于QEMU，但是在真实的硬件上，这是个坏主意；真实的硬件将RAM和设备放置在不可预测的物理地址上，因此(例
如)0x8000000处可能没有RAM，但xv6希望能够在这里存储内核。更严肃的内核设计利用页表将任意的硬件物理内存布局转化为可预测的内核虚拟地址布局。

RISC-V支持物理地址级别的保护，但xv6没有使用这个功能。

在内存大的机器上，使用RISC-V对“超级页面”的支持可能是更有用的。而当物理内存很小的时候，小页更有用，它允许系统在分配页面和向磁盘page-out时使用更精确的单位。例如，如果一个程序只使用8KB的内存，那么给它一个4MB的超级物理内存页面就是浪费。更大的页面适合具有更大内存的计算机，并且可以减少页表操作的开销。

xv6内核缺少一个类似malloc这样可以为小对象提供内存的分配器，这使得内核无法使用需要动态分配内存的复杂数据结构。

内存分配一直都是热门的话题，基本问题是：如何有效使用有限的内存和为未知的未来请求做准备。今天人们更关心速度而不是空间利用率。此外，一个更精细的内核可能会分配许多不同大小的小块，而不是(如xv6)仅仅分配4096字节的块；一个真正的内核分配器需要处理小块和大块的分配。

# Chapter 4 Traps and syscalls

有三种事件会导致CPU搁置指令的正常执行，并强制将控制权转移到处理该事件的特殊代码。一种情况是系统调用，当一个用户程序执行ecall指令，要求内核为它做一些事情。另一种情况是一个异常(exception)：一条指令(用户或内核)做了一些非法的事情，比如除以零或者使用了一个无效的虚拟地址。第三种情况是设备中断(device interrupt)，当设备发出需要注意的信号时出现，例如当磁盘硬件完成读写请求时。

本书使用陷阱(trap)作为这些情况的通用术语。通常，陷阱发生时正在执行的任何代码都需要在之后恢复，并且不需要知道发生了什么事情。也就是说，我们通常希望陷阱是透明的；这对于设备中断来说尤其重要，因为被中断的代码通常不会意识到出现了陷阱。通常的顺序是，一个陷阱强制将控制权转移到内核；内核保存寄存器和其他状态，以便可以继续执行；内核执行适当的处理程序代码(例如，系统调用实现或设备驱动程序)；内核恢复保存的状态并从阱返回；原始代码继续执行它中断的地方。

Xv6 在内核中处理所有的陷阱；陷阱不会交付给用户代码。在内核中处理陷阱对于系统调用来说是很自然的。这对于中断是有意义的，因为隔离性要求只允许内核使用设备，而内核可以实现在多个进程之间共享设备。对于异常也是有意义的，因为xv6通过杀死违规程序来响应用户空间的所有异常。

Xv6陷阱处理分为四个阶段: RISC-V CPU 执行的硬件操作，为内核C代码准备的一些汇编指令，决定陷阱处理方式的C函数，以及系统调用或设备驱动程序服务例程。虽然这三种陷阱类型之间的共性表明，内核可以通过单一的代码路径处理所有陷阱，但是对于三种不同的情况(用户空间陷阱、内核空间陷阱和定时器中断)，使用单独的代码是更为方便的。处理陷阱的内核代码(汇编程序或C)通常称为处理handler；第一个handler指令通常用汇编程序(而不
是C)编写，有时也称为向量(vector)。

## 4.1 RISC-V trap machinery

每个 RISC-V CPU都有一组控制寄存器，内核编写这些寄存器来告诉CPU如何处理陷阱，内核可以通过读取这些寄存器来发现已经发生的陷阱。RISC-V文档包含了完整说明。riscv.h (kernel/riscv.h: 1)包含了xv6使用的定义。下面是最重要的寄存器的概述:

- stvec：内核在这里写入陷阱处理程序的地址；RISC-V 跳转到stvec中的地址来处理陷阱。
- sepc: 当陷阱发生时，RISC-V在这里保存程序计数器(因为pc随后被stvec中的值覆盖)。sret(从陷阱返回)指令将sepc复制到pc。内核可以编写sepc来控制sret的去向。
- scause：RISC-V 在这里放一个数字来描述陷阱的原因。
- sscratch：内核在这里放置一个值，这个值在陷阱处理程序的一开始就派上了用场。(译者注：scratch直译是抓、挠的意思。不懂。)
- sstatus：sstatus中的SIE位控制是否启用设备中断。如果内核清除SIE，RISC-V 将推迟设备中断，直到内核设置SIE。SPP位指示陷阱是来自用户模式还是管理模式，并控制sret返回到什么模式。

上述寄存器与在管理模式下处理的陷阱有关，它们不能在用户模式下读取或写入。对于在机器模式下处理的陷阱，有一组类似的控制寄存器；xv6只在定时器中断这种特殊情况下使用它们。

多核芯片上的每个CPU都有自己的一组寄存器，在任何时候，都可能有多个CPU在处理一个陷阱。

当需要处理陷阱(force a trap)时，RISC-V硬件对所有陷阱类型(定时器中断除外)执行以下操作：

1. 如果陷阱是一个设备中断，并且sstatus SIE位是被清除的，不执行以下任何操作。

2. 通过清除sstatus中的SIE位来禁用中断。

3. 将pc复制到sepc。

4. 将当前模式(用户或管理)保存在sstatus中的 SPP 位中。

5. 设置scause来反映陷阱的原因。

6. 设置模式为管理模式。

7. 将stvec复制到pc。

8. 在新的pc位置开始执行。

请注意，CPU不会切换到内核页表，不会切换到内核栈，也不会保存除pc以外的任何寄存器。内核软件必须执行这些任务。CPU在陷阱期间尽量只进行少量工作的一个原因是为软件提供灵活性；例如，某些操作系统在某些情况下省略页表切换以提高陷阱性能。

值得考虑的是上面列出的步骤是否可以省略一些，从而加快trap的处理速度。虽然有些情况下，省略一些步骤也可以工作，但通常情况下，省略步骤是十分危险的。例如，假设 CPU 没有切换程序计数器，此时一个来自用户空间的trap可以切换到管理模式，同时仍然运行用户指令。这些用户指令就可以打破user/kernel隔离，例如，通过修改satp寄存器来指向允许访问所有物理内存的页表。因此，CPU切换到一个内核指定的指令地址(即stvec)是很重要的。

## 4.2 Traps from user space

xv6处理陷阱的方式，取决于它是在内核还是在用户代码中执行。下面是来自用户代码的陷阱的例子；4.5描述了来自内核代码的陷阱。

如果用户程序发出系统调用(ecall指令)，或者做了非法的事情，或者设备中断，则可能会出现陷阱。陷阱从用户空间的高级路径(high-level path)是uservec(kernel/trampoline.S: 
16)，然后是 usertrap (kernel/trap.c: 37)；返回时的路径为，usertrapret (kernel/trap.c: 90)，然后是userret(kernel/trampoline.S: 88)。

设计xv6陷阱处理的一个主要限制是，RISC-V硬件在处理陷阱时不会切换页表。这意味着stvec中的陷阱处理程序地址必须在用户页表中有一个有效的映射，因为这是陷阱处理代码开始执行时生效的页表。此外，xv6的陷阱处理代码需要切换到内核页表；为了能够在切换之后继续执行，内核页表也必须有stvec指向的处理程序的映射。

xv6使用trampoline page来满足这些需求。trampoline page包含uservec，stvec指向的xv6陷阱处理代码。trampoline page映射到每个进程的页表的TRAMPOLINE地址处，该地址位于虚拟地址空间的末尾，因此它将位于进程自己使用的内存之上。trampoline page也被映射到内核页表中的地址TRAMPOLINE处。参考图2.3和图3.3。因为trampoline page被映射到用户页面表中，带有 PTE_U标志，陷阱可以在管理模式下开始执行。因为trampoline page被映射到内核地址空间中的相同地址处，所以在切换到内核页表之后，trap处理程序可以继续执行。

uservec陷阱处理程序的代码在trampoline.S (kernel/trampoline.S: 16)中。当uservec启动时，32个寄存器存储了被中断的用户代码所拥有的一些数据。这32个值需要保存在内存中的某个地方，这样，当陷阱返回到用户空间时，它们就可以被恢复。我们需要使用寄存器来保存这些暂存在内存中的数据的地址，但这时是没有通用寄存器可用的。幸运的是RISC-V提供了sscratch寄存器。在uservec最开始的地方，csrrw指令交换了a0和scratch的内容。现在用户代码的a0就保存在scratch中；并且uservec就有一个寄存器(a0)可以使用；a0存放着内核之前放在sscratch中的值。

uservec的下一个任务是保存32个用户寄存器。在进入用户空间之前，内核将sscratch指向每个进程的trapframe结构，该结构有足够空间保存32个用户寄存器(kernel/proc.h: 44)。因为 satp仍然是指用户页表，uservec需要将trapframe映射到用户
地址空间。当每个进程被创建时，xv6都为进程的trapframe分配一个页面，并安排它始终映射到用户虚拟地址TRAPFRAME，它就在TRAMPOLINE下面。进程的p->trapframe也指向trapframe，尽管是在它的物理地址，所以内核可以通过内核页表使用它。

因此，在交换a0和sscratch之后，a0持有指向当前进程的trapframe的指针。现在所有的用户寄存器都被保存在了trapframe中，包括用户的a0，这个a0的值是从sscratch中读出来的。

trapframe包含了当前进程的内核栈的地址、当前CPU的hartid、 usertrap函数的地址以及内核页表的地址。uservec检索这些值，将satp切换到内核页表，并调用usertrap。

usertrap的工作是确定陷阱的原因，处理它，然后返回(kernel/trap.c: 37)。它首先改变stvec，这样一个陷阱在内核中将由 kernelvec而不是uservec来处理。它保存了sepc寄存器(保存的用户程序计数器)，因为usertrap可能会调用yield来切换到另一个进程的内核线程，而该进程可能会返回到用户空间，在此过程中它将修改sepc。如果陷阱是一个系统调用，则usertrap调用 syscall来处理它；如果设备中断，则调用devintr；否则它是一个异常，内核将终止故障进程。系统调用的情况下，会对已保存的用户程序计数器进行+4的操作，因为RISC-V使程序指针指向ecall指令，在完成syscall后，会从ecall指令后面的那条指令继续执行。在退出的过程中，usertrap检查进程是否已经被杀死或者是否需要让出(yield)CPU(如果这个陷阱是一个计时器中断)。

返回用户空间的第一步是调用usertrapret(kernel/trap.c: 90)。这个函数设置RISC-V控制寄存器，为将来用户空间的陷阱做准备。这涉及更改stvec以引用uservec，准备uservec所依赖的trapframe，并将sepc设置为先前保存的用户程序计数器。最后，usertrapret在用户和内核页表中映射的trampoline page上调用userret，这是因为userret中的汇编代码将切换页表。

usertrapret对userret的调用将读取a0中保存的TRAPFRAME和a1中保存的指向用户页表的指针(kernel/trampoline.S: 88)。userret将satp切换到进程的用户页表。回想一下，用户页表同时映射trampoline page和TRAPFRAME，但没有映射内核的其他内容。trampoline page在用户和内核页表中映射到相同的虚拟地址，这一事实允许uservec在更改satp后继续执行。userret复制trapframe中保存的用户a0到sscratch中，为后面的交换做准备。从这里开始，userret唯一可以使用的数据只有寄存器内容和trapframe的内容。接下来userret从trapframe中恢复保存的用户寄存器，然后执行a0和sscratch的交换以恢复用户a0，并将TRAPFRAME放在sscratch中以便下一次trap使用，最后执行sret返回到用户空间。

## 4.3 Code: Calling system calls

第二章以initcode.S调用exec系统调用结束(user/initcode.S:11)。让我们看看用户调用是如何在内核中实现exec系统调用的。

initcode.S将exec的参数放在寄存器a0和a1中，并将系统调用号放在a7中。系统调用号与syscalls数组中的条目相匹配，syscalls是一个函数指针表(kernel/syscall.c: 108)。ecall指令陷入内核，调用uservec，usertrap，然后syscall执行，就像前面所讲的那样。

syscall(kernel/syscall.c:133)从trapframe中保存的a7中检索系统调用号，并使用它在syscalls中查找。对于第一次系统调用，a7包含了SYS_exec(kernel/syscall.h:8)，结果是对sys_exec(exec的系统调用实现函数)的调用。

当sys_exec返回时，syscall将其返回值记录在p->trapframe->a0中。这将导致原始用户空间调用exec()返回该值，因为RISC-V上的C调用约定将返回值放在a0中。系统调用通常用返回负数来表示错误，而零或正数则表示成功。如果系统调用号无效，syscall打印一个错误并返回-1。

## 4.4  Code: System call arguments

内核中的系统调用的实现需要查找用户代码传递的参数。因为用户代码调用系统调用包装函数，所以参数默认放置在RISC-V C调用通常放置它们的地方：寄存器。内核陷阱代码将用户寄存器保存到当前进程的trapframe中，并可以在这里找到它们。内核函数argint、argaddr和argfd以整数、指针或文件描述符的形式从trapfrme中检索第n个系统调用参数。它们都通过调用argraw来获得目标寄存器(kernel/syscall.c: 35)。

一些系统调用传递指针作为参数，内核必须使用这些指针来读写用户内存。例如，exec系统调用向内核传递一个指针数组，指向用户空间中的字符串参数。这些指针有两个问题：一，用户程序可能存在漏洞或恶意，并且可能向内核传递一个无效的指针或一个旨在诱使内核访问内核而不是用户内存的指针。二，xv6内核页表映射与用户页表映射不同，因此内核不能使用普通指令从用户提供的地址加载或存储。

内核实现了在用户提供的地址处安全传输数据的函数。fetchstr 就是一个例子(kernel/syscall.c: 25)。文件系统调用如exec使用fetchstr从用户空间检索字符串文件名参数。fetchstr调用copyinstr来完成这项艰巨的工作。

copyinstr(kernel/vm.c: 398)从用户页表pagetable中的虚拟地址srcva处复制最多max字节到dst。因为pagetable不是当前的页表，copyinstr使用walkaddr(walkaddr又调用walk)在pagetable中查找srcva，产生物理地址pa0。内核将每个物理内存地址映射到相应的内核虚拟地址，因此copyinstr可以直接将字符串从pa0复制到dst。walkaddr(kernel/vm.c: 104)检查用户提供的虚拟地址是否是进程用户地址空间的一部分，因此程序无法欺骗内核读取其他内存。copyout与copyinstr相似，功能是将数据从内核复制到用户提供的地址。

## 4.5 Traps from kernel space

xv6对CPU陷阱寄存器的配置有所不同，这取决于是用户代码还是内核代码正在执行。当内核代码在CPU上执行时，内核将stvec指向汇编代码kernelvec(kernel/kernelvec.S: 10)。由于xv6已经在内核中，所以kernelvec可以使用被设为内核页表satp，以及引用有效内核栈的栈指针。kernelvec将所有32个寄存器推送到栈上，稍后将从栈中恢复这些寄存器，以便被中断的内核代码可以在不受干扰的情况下继续运行。

kernelvec将寄存器保存在被中断的内核线程的栈上，这是合理的，因为寄存器值就属于该线程。如果陷阱导致切换到另一个线程上，在这种情况下，这样操作尤为重要。此时陷阱实际上会将从新线程的栈返回，而被中断线程的寄存器被安全地留在其栈上。

保存寄存器后，kernelvec跳转到kerneltrap(kernel/trap.c: 134)。kerneltrap处理两种陷阱: 设备中断和异常。它调用devintr(kernel/trap.c: 177)来检查和处理前者。如果这个陷阱不是一个设备中断，那么它必须是一个异常，如果它发生在xv6内核中，那么这将是一个致命的错误；内核会调用panic并停止执行。

如果由于计时器中断而调用了kerneltrap，并且进程的内核线程正在运行(而不是调度器线程)，那么kerneltrap调用yield以给其他线程运行的机会。在某个时候，其中一个线程会退出，让我们的线程和它的kerneltrap重新开始。第七章解释了在yield过程中会发生什么。

当kerneltrap的工作完成后，它需要返回到被陷阱打断的代码。因为yield可能扰乱了sepc和放在sstatus中的之前的状态模式，所以kerneltrap在开始时会保存它们。它现在恢复那些控制寄存器并返回到kernelvec(kernel/kernelvec.S: 48)。kernelvec从栈中弹出保存的寄存器，执行secret，将sepc复制到pc并恢复被中断的内核代码。

如果由于计时器中断，kerneltrap调用yield，那么陷阱返回是如何发生的呢。这是个好问题。

当CPU从用户空间进入内核时，xv6将CPU的stvec设置为kernelvec；你可以在usertrap(kernel/trap.c:29)中看到这一点。当内核已经开始运行而stvec仍为uservec这段时间，不发生设备中断是至关重要的。幸运的是，RISC-V总是在它开始设置陷阱时禁用中断，而xv6在设置stvec之前不会再次启用中断。

## 4.6 Page-fault exceptions

xv6对异常的响应非常简单：如果异常发生在用户空间，内核就会终止错误处理过程。如果一个异常发生在内核中，内核就会恐慌。真正的操作系统通常会以更有趣的方式做出反应。

例如，许多内核使用页面错误(page fault)来实现写时复制fork(copy on write，COW)。为了解释写时复制fork，考虑一下xv6的fork，在第3章中有描述。fork会使子进程的初始内存内容与父进程在使用fork时的内存内容相同。xv6使用uvmcopy(kernel/vm.c:301)实现fork，它为子进程分配物理内存并将父进程内存内容复制到其中。如果父进程和子进程可以共享父进程的物理内存，那么效率会更高。然而，这种简单的实现没有用，因为它会导致父进程和子进程在对共享栈堆的写操作中断彼此的执行。

通过合理利用页表权限和页面错误，父进程和子进程可以安全地共享物理内存。如果使用的虚拟地址在页表中没有映射，或者映射的PTE_V标志是被清除的，或者试图执行无权限的操作(PTE_R、PTE_W、PTE_X、PTE_U)，则CPU将报告页错误异常。RISC-V区分了三种页面错误: 加载页面错误(当加载指令无法翻译其虚拟地址时)、存储页面错误(当存储指令无法翻译其虚拟地址时)和指令页面错误(当程序计数器中的地址无法翻译时)。scause寄存器表示页面错误的类型，stval寄存器存放着无法翻译的地址。

实现写时复制fork的基本思路是：父进程和子进程最初共享所有物理页面，但是每个页面都映射为只读(pte_W标志位清除)。父子进程都可以从共享的物理内存中读取数据。但如果有进程试图写入，RISC-V CPU将引发一个页面错误异常。内核的陷阱处理程序通过分配一个新的物理内存页面，并复制错误地址映射到的物理页面的内容到新页面来响应。内核将更改错误进程的页表中的相关 PTE，以指向新页面并允许读写，然后再次执行那条导致错误的指令。因为PTE允许写操作，所以重新执行的指令将无故障地执行。写时复制需要book-keeping来帮助决定何时释放物理页面，因为fork、page-faults、execs和exits的多次执行，每个页面可以由多个页表引用。在book-keeping支持下可实现的优化: 如果进程发生存储页面错误，并且物理页面只从该进程的页表中引用，则不需要复制。

写时复制使fork更快，因为fork不需要复制内存。虽然后面出现写入操作时，一些内存也会进行复制，但通常情况下，大部分内存永远不必被复制。一个常见的例子是fork后面跟着exec：fork后可能会执行一些写操作，但是后面子进程的exec会释放从父进程继承的大部分内存。写时复制fork消除了复制这个内存的需要。此外，写时复制fork是透明的：不需要修改应用程序就能从中获利。

页表和页面错误的组合，除了写时复制fork之外，还有很多有趣的可能性。另一个广泛使用的特性叫做延迟分配(lazy allocation)，它由两部分组成。首先，当一个应用程序通过调用sbrk来请求更多的内存时，内核会注意大小的增加，但实际上不分配物理内存，也不为新的虚拟地址范围创建PTEs。第二，当其中一个新地址出现页面错误时，内核会分配一页物理内存并将其映射到页表中。像写时复制fork一样，内核可以对应用程序透明地实现延迟分配。

由于大多数时候应用程序请求的内存比实际需求要大，因此延迟分配是一个好办法：内核完全没有必要为应用程序从不使用的页面做工作。此外，如果应用程序要求大幅增加地址空间，那么不进行延
迟分配的sbrk代价很高: 如果应用程序请求1GB内存，那么内核必须分配2621444096字节的页面，并将其归零。延迟分配使得这种成本随着时间的推移而分散。另一方面，延迟分配会给页面错误带来额外的开销，这涉及到内核/用户转换。操作系统可以通过在每次页面错误时分配一批连续的页面，而不是只分配一个页面，并为这种页面错误书写专用的内核进出代码，从而降低开销。

另一个广泛使用的利用页面错误的特性是需求分页(demand paging)。在exec中，xv6很早就将应用程序的所有文本和数据加载到内存中。由于应用程序可能很大，并且从磁盘读取代价很高，因此用户可能就会注意到这种启动成本：当用户从shell启动大型应用程序时，用户可能需要很长时间才能看到响应。为了提高响应时间，现代内核为用户地址空间创建了页表，但是为页面标记了无效的PTEs。当出现页面错误时，内核从磁盘读取页面内容并将其映射到用户地址空间。就像写时复制fork和延迟分配一样，内核可以对应用程序透明地实现这个特性。

在计算机上运行的程序可能需要比计算机内存更多的内存。为了更好地处理这些问题，操作系统可能会实现磁盘分页(paging to disk)。构思如下：在内存中只存储一小部分用户页面，剩下的存储在磁盘中的分页区域(paging area)。内核将与存储在分页区域(即不在内存中)的内存对应的PTEs标记为无效。如果一个应用程序试图使用一个被paged out到磁盘的页面，那么该应用程序将引发一个页面错误，然后该页面必然被paged in到内存：内核陷阱处理程序将分配一个物理内存页面，从磁盘读取该页面到内存，并修改相关的PTE以指向内存。

如果一个页面需要被paged in，但是没有空闲的物理内存，会发生什么？在这种情况下，内核必须首先释放一个物理页面，将其page out或驱逐到磁盘上的分页区域，并将引用该物理页面
的PTEs标记为无效。驱逐的代价是很昂贵的，所以尽量避免比较好：如果应用程序只使用其内存页面的一个子集，子集的大小总和不超过物理内存大小。这个属性通常被称为“具有良好的访问局部性”。与许多虚拟内存技术一样，内核通常以一种对应用程序透明的方式实现磁盘分页。

无论硬件提供多少内存，计算机通常能使用的依旧只有一点点甚至没有空闲的物理内存使用。例如，云服务提供商可以在一台机器上同时为多个用户提供服务，以便有效地使用他们的硬件。又例如，用户在智能手机上运行许多应用程序，只需要很少的物理内存。在这种情况下，分配一个页面可能需要首先驱逐一个已存在的页面。因此，当空闲物理内存不足时，分配的代价是很昂贵的。

当空闲内存不足时，延迟分配和需求分页特别有用。在sbrk或exec中过早地分配内存会产生额外的驱逐成本。此外，可能活跃 任务会被浪费。因为在这个任务使用该页面之前，操作系统可能已经将其驱逐。

结合分页异常和页面错误异常，还可以实现自动扩展栈和内存映射文件。

## Real world

trampoline和trapframe似乎过于复杂。一个原因是，RISC-V 在处理陷阱时尽量少做事，提高了快速处理掉陷阱的可能性，这是很重要的。因此，内核陷阱处理程序的前几条指令必须在用户环境中有效地执行: 使用用户页表和用户寄存器内容。陷阱处理程序最初并不知道这些有用的信息：比如正在运行的进程的id或者内核页表的地址。一个解决方案是可能的，因为RISC-V提供了受保护的地方，内核可以在进入用户空间之前将信息隐藏起来: sscratch寄存器和指向内核内存的用户页表条目，但由于缺少PTE_U而受到保护。xv6的trampoline和trapframe就利用了RISC-V的这些特性。

如果将内核内存映射到每个进程的用户页表(带有适当的PTE权限标志) ，trampoline页面就没有存在的必要了。从用户空间到内核时的页表切换也就没有必要了。这反过来又允许内核中的系统调用利用前进程的已被映射的用户内存，允许内核代码直接解引用用户指针。许多操作系统已经使用这些想法来提高效率。xv6避免使用它们是为了减少由于无意中使用了用户指针而在内核中出现安全错误的可能性，并减少确保用户和内核虚拟地址不重叠所带来的复杂问题。

成熟的操作系统实现了写时复制、延迟分配、需求分页、磁盘分页、内存映射文件等。此外，成熟的操作系统将尝试使用所有的物理内存，无论是应用程序还是缓存(例如，文件系统的缓冲区缓存，我们将在后面的章节 8.2 中讨论)。xv6在这方面是幼稚的: 你希望你的操作系统能够完全利用好你花钱买来的物理内存，但是xv6不这样做。此外，如果xv6内存不足，它将向正在运行的应用程序返回一个错误或终止该应用程序，而不是驱逐另一个应用程序的页面。

# Chapter 5 Interrupts and device drivers

驱动程序是操作系统中管理特定设备的代码: 它配置设备硬件，告诉设备执行操作，处理由此产生的中断，并与可能正在等待设I/O的进程交互。驱动程序代码可能很棘手，因为驱动程序与它所管理的
设备并发执行。此外，驱动程序必须理解设备的硬件接口，这可能是复杂和枯燥的文档。

需要操作系统注意的设备通常可以配置为产生中断，这是一种陷阱。内核陷阱处理代码识别设备何时引发中断并调用中断处理程序。在xv6中，这种dispatch发生在devintr(kernel/trap.c: 177)中。

许多设备驱动程序在两个上下文中执行代码: 上半部分在进程的内核线程中运行，下半部分在中断时执行。上半部分是通过系统调用来调用的，比如read和write这种需要设备执行I/O的系统调用。这段代码可以要求硬件启动一个操作(例如，要求从磁盘读取一个块)；然后代码等待操作完成。最终设备完成操作并发出
中断。驱动程序的中断处理程序(interrupt handler)充当下半部分，指出已完成的操作，在适当的情况下唤醒等待进程，并告诉硬件开始处理任何等待的下一个操作。



















































